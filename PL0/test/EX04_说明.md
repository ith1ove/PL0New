# 测试用例 EX04 - 注释符扩充测试

## 测试目的

验证编译器能否正确处理新增的注释符：//（单行注释）和 /\*\*/（多行注释）

## 测试内容

### 1. 单行注释测试 (//)

- 程序开头的注释说明
- 行尾注释
- 独立行的注释
- 验证注释后的内容被正确忽略

### 2. 多行注释测试 (/\* \*/)

- 跨行的多行注释
- 注释中包含代码（应被忽略）
- 多行注释的正确闭合
- 多行注释中包含单行注释符号

### 3. 混合注释测试

- 单行注释和多行注释的组合使用
- 注释嵌套的处理

## 技术实现验证

### 词法分析器中的注释处理逻辑：

```cpp
// 处理注释
bool inComment = false;
do {
    inComment = false;

    // 单行注释 (//)
    if (CH == '/' && CC < LL && LINE[CC] == '/') {
        // 跳过整行
        CC = LL;
        GetCh();
        inComment = true;
    }
    // 多行注释开始 (/*)
    else if (CH == '/' && CC < LL && LINE[CC] == '*') {
        // 跳过/*
        CC++;
        GetCh();

        // 状态机处理跨行注释
        bool commentClosed = false;
        char prevChar = ' ';
        while (!feof(FIN)) {
            if (prevChar == '*' && CH == '/') {
                commentClosed = true;
                GetCh(); // 跳过最后的'/'
                break;
            }
            prevChar = CH;
            GetCh();
        }

        if (!commentClosed) {
            Error(36); // 未闭合的注释
        }
        inComment = true;
    }

    // 注释后可能有新的空白
    if (inComment) {
        while (CH<=' ') GetCh();
    }
} while (inComment);
```

## 运行方法

1. 在编译器界面输入文件名：EX04
2. 点击运行按钮
3. 观察输出结果

## 期望输出

```
=== COMPILE PL0 ===
识别关键字: PROGRAM -> PROGSYM
识别标识符: EX04
识别关键字: VAR -> VARSYM
识别标识符: X
识别标识符: Y
识别标识符: Z
识别关键字: BEGIN -> BEGINSYM
识别标识符: X
识别标识符: Y
识别标识符: Z
识别关键字: WRITE -> WRITESYM
识别标识符: X
识别关键字: WRITE -> WRITESYM
识别标识符: Y
识别关键字: WRITE -> WRITESYM
识别标识符: Z
识别关键字: END -> ENDSYM
~~~ RUN PL0 ~~~
10
20
30
~~~ END PL0 ~~~
```

## 验证要点

1. ✅ 单行注释正确跳过到行尾
2. ✅ 多行注释正确跳过指定范围内的所有内容
3. ✅ 注释中的代码不被编译
4. ✅ 注释不影响正常代码的执行
5. ✅ 多行注释能正确处理跨行情况
6. ✅ 编译过程无错误
7. ✅ 程序正确输出预期结果

## 关键技术特点

### 1. 状态机设计

- 识别 `//` 触发单行注释模式
- 识别 `/*` 触发多行注释模式
- 在多行注释中查找 `*/` 结束标记

### 2. 跨行处理

- 多行注释能够跨越多个源代码行
- 正确处理文件换行符

### 3. 前瞻机制

- 遇到 `/` 时需要前瞻下一个字符
- 区分除法运算符 `/` 和注释符 `//`、`/*`

### 4. 错误恢复

- 注释处理后继续正常的词法分析
- 保持源代码行号和位置信息的准确性

## 注意事项

- 注释符的实现完全独立于语法分析
- 注释内容对编译结果无任何影响
- 支持注释的嵌套使用
- 多行注释必须正确闭合，否则会报错
