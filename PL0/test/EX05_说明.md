# 测试用例 EX05 - 不规范注释错误处理测试

## 测试目的
验证编译器对不规范注释符的错误处理能力，展示各种注释错误会导致的后果

## 测试内容

### 主要错误类型：未闭合的多行注释

**错误代码示例：**
```pascal
/* 这是一个未闭合的多行注释
B := 20;

// 程序应该在这里报错，因为多行注释没有正确闭合
```

## 期望的错误处理行为

### 1. 错误检测
编译器应该能检测到未闭合的多行注释，并报告错误。

### 2. 错误代码
根据实现，应该触发 `Error(36)` - "未闭合的注释"

### 3. 期望输出
```
=== COMPILE PL0 ===
识别关键字: PROGRAM -> PROGSYM
识别标识符: EX05
识别关键字: VAR -> VARSYM
识别标识符: A
识别标识符: B
识别关键字: BEGIN -> BEGINSYM
识别标识符: A
***              ^36
ERROR IN PL/0 PROGRAM
```

## 技术实现分析

### 错误检测逻辑：
```cpp
// 多行注释开始 (/*)
else if (CH == '/' && CC < LL && LINE[CC] == '*') {
    // 跳过/*
    CC++;
    GetCh();
    
    // 状态机处理跨行注释
    bool commentClosed = false;
    char prevChar = ' ';
    while (!feof(FIN)) {
        if (prevChar == '*' && CH == '/') {
            commentClosed = true;
            GetCh(); // 跳过最后的'/'
            break;
        }
        prevChar = CH;
        GetCh();
    }
    
    if (!commentClosed) {
        Error(36); // 未闭合的注释 ← 这里触发错误
    }
    inComment = true;
}
```

## 其他可能的注释相关错误

### 1. 文件结束时的未闭合注释
- **现象**：多行注释开始后，文件突然结束
- **后果**：触发 Error(36)
- **示例**：`/* 注释开始但是文件结束了`

### 2. 嵌套多行注释（如果不支持）
- **现象**：`/* 外层注释 /* 内层注释 */ 外层继续 */`
- **后果**：可能导致注释提前结束或解析错误

### 3. 单独的 / 字符处理
- **现象**：`/` 后面既不是 `*` 也不是 `/`
- **处理**：应该被识别为除法运算符或报错

## 运行方法
1. 在编译器界面输入文件名：EX05
2. 点击运行按钮
3. 观察错误输出

## 验证要点
1. ✅ 编译器能检测到未闭合的多行注释
2. ✅ 报告准确的错误信息和位置
3. ✅ 错误处理不会导致程序崩溃
4. ✅ 错误信息有助于调试
5. ✅ 编译过程在错误后正确终止

## 错误恢复机制

### 当前实现的特点：
- 检测到未闭合注释时立即报错
- 错误计数器 `ERR++` 增加
- 编译过程继续，但最终不会执行代码
- 输出 "ERROR IN PL/0 PROGRAM"

## 改进建议

### 可能的增强功能：
1. **更详细的错误信息**：显示注释开始的行号
2. **错误恢复**：尝试找到可能的注释结束位置
3. **警告机制**：对可疑的注释模式给出警告

## 对比测试

### 正确的注释：
```pascal
/* 这是正确的多行注释 */
// 这是正确的单行注释
```

### 错误的注释：
```pascal
/* 这是错误的多行注释
// 没有正确闭合
```

## 实际后果分析

### 1. 编译失败
- 程序无法正常编译
- 不会生成可执行代码

### 2. 源码误解
- 注释后的代码可能被当作注释内容忽略
- 导致程序逻辑错误

### 3. 调试困难
- 未闭合注释可能影响大段代码
- 错误定位可能比较困难

这个测试用例有效地验证了编译器的错误处理机制，确保了注释功能的健壮性。
